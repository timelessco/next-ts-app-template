/* eslint-disable @eslint-community/eslint-comments/disable-enable-pair */
/* eslint-disable import-x/no-named-as-default-member */
// Thanks to Epic Stack for the original script
// https://github.com/epicweb-dev/epic-stack/blob/d663177944e97f2705ec69482d3cc3c56865b2c8/other/build-icons.ts

import path from "node:path";

import { $ } from "execa";
import fsExtra from "fs-extra";
import { glob } from "glob";
import { parse } from "node-html-parser";

import { vet } from "./utils/try.ts";

const cwd = process.cwd();
const inputDirectory = path.join(cwd, "src", "icons", "svg");
const inputDirectoryRelative = path.relative(cwd, inputDirectory);
const outputDirectory = path.join(cwd, "src", "icons");
const publicDirectory = path.join(cwd, "public");
const publicSvgDirectory = path.join(publicDirectory, "svg");

// Check if input directory exists
const dirExists = await vet(() => fsExtra.pathExists(inputDirectory));
if (!dirExists.unwrapOr(false)) {
	throw new Error(`Input directory ${inputDirectoryRelative} not found`);
}

// Create output and public directories if they don't exist
const ensureDirsResult = await vet(async () => {
	await fsExtra.ensureDir(outputDirectory);
	await fsExtra.ensureDir(publicDirectory);
	await fsExtra.ensureDir(publicSvgDirectory);
});

if (ensureDirsResult.isErr()) {
	console.error(
		`Failed to create directories ${outputDirectory}, ${publicDirectory}, ${publicSvgDirectory}`,
	);
	throw ensureDirsResult.error;
}

const filesResult = vet(() =>
	glob
		.sync("**/*.svg", {
			cwd: inputDirectory,
		})
		.sort((a, b) => {
			return a.localeCompare(b);
		}),
);

if (filesResult.isErr()) {
	console.error(`Failed to find SVG files in ${inputDirectoryRelative}`);
	throw filesResult.error;
}

const files = filesResult.value;

const shouldVerboseLog = process.argv.includes("--log=verbose");
// eslint-disable-next-line @typescript-eslint/no-empty-function
const logVerbose = shouldVerboseLog ? console.log : () => {};

if (files.length === 0) {
	console.log(`No SVG files found in ${inputDirectoryRelative}`);
} else {
	await generateIconFiles();
}

async function generateIconFiles() {
	const spriteFilepath = path.join(publicDirectory, "svg/sprite.svg");
	const typeOutputFilepath = path.join(outputDirectory, "icon-name.d.ts");
	// We use the unwrapOr to avoid throwing an error because they will be created if they don't exist
	const spriteResult = await vet(() =>
		fsExtra.readFile(spriteFilepath, "utf8"),
	);
	const currentSprite = spriteResult.unwrapOr("");
	// We use the unwrapOr to avoid throwing an error because they will be created if they don't exist
	const typesResult = await vet(() =>
		fsExtra.readFile(typeOutputFilepath, "utf8"),
	);
	const currentTypes = typesResult.unwrapOr("");

	const iconNames = files.map((file) => {
		return iconName(file);
	});

	const spriteUpToDate = iconNames.every((name) => {
		return currentSprite.includes(`id=${name}`);
	});
	const typesUpToDate = iconNames.every((name) => {
		return currentTypes.includes(`"${name}"`);
	});

	if (spriteUpToDate && typesUpToDate) {
		logVerbose(`Icons are up to date`);
		return;
	}

	logVerbose(`Generating sprite for ${inputDirectoryRelative}`);

	await generateSvgSprite({
		filesProp: files,
		inputDirectoryProp: inputDirectory,
		outputPath: spriteFilepath,
	});
	const svgoResult = await vet(async () => {
		const result = await $`svgo --precision 2 ${spriteFilepath}`;
		return result;
	});
	if (svgoResult.isErr()) {
		logVerbose(`Warning: Failed to optimize SVG sprite`);
		console.warn(svgoResult.error);
	}

	for (const file of files) {
		logVerbose("âœ…", file);
	}

	logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

	const stringifiedIconNames = iconNames.map((name) => {
		return JSON.stringify(name);
	});

	const typeOutputContent = `// This file is generated by npm run build:icons

export type IconName =
\t| ${stringifiedIconNames.join("\n\t| ")};
`;
	await writeIfChanged(typeOutputFilepath, typeOutputContent);

	logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

	await writeIfChanged(
		path.join(outputDirectory, "README.md"),
		`# Icons

Everything in this directory is generated by \`pnpm run build:icons\`.
This directory contains SVG icon names that are used by the app.

Scripts are located in the \`scripts/build-icons.ts\` directory.
Original SVG files are located in the \`src/app/icons/svg\` directory.
The icon sprite is generated within the public directory at \`/svg/sprite.svg\`.
`,
	);

	console.log(`Generated ${files.length} icons`);
}

function iconName(file: string) {
	return file.replace(/\.svg$/u, "");
}

/**
 * Creates a single SVG file that contains all the icons
 * @param {object} options - Options for the sprite generation
 * @param {string[]} options.filesProp - List of SVG files to include
 * @param {string} options.inputDirectoryProp - Directory containing the SVG files
 * @param {string} options.outputPath - Output path for the sprite
 * @returns {Promise<boolean>} Whether the sprite was changed
 */
async function generateSvgSprite({
	filesProp,
	inputDirectoryProp,
	outputPath,
}: {
	filesProp: string[];
	inputDirectoryProp: string;
	outputPath: string;
}) {
	// Each SVG becomes a symbol and we wrap them all in a single SVG
	const symbolPromises = filesProp.map(async (file) => {
		const filepath = path.join(inputDirectoryProp, file);
		const inputResult = await vet(() => fsExtra.readFile(filepath, "utf8"));

		if (inputResult.isErr()) {
			console.error(`Failed to read SVG file: ${filepath}`);
			throw inputResult.error;
		}

		const parseResult = vet(() => parse(inputResult.value));
		if (parseResult.isErr()) {
			console.error(`Failed to parse SVG file: ${filepath}`);
			throw parseResult.error;
		}

		const root = parseResult.value;
		const svg = root.querySelector("svg");
		if (!svg) {
			throw new Error(`No SVG element found in ${filepath}`);
		}

		svg.tagName = "symbol";
		svg.setAttribute("id", iconName(file));
		svg.removeAttribute("xmlns");
		svg.removeAttribute("xmlns:xlink");
		svg.removeAttribute("version");
		svg.removeAttribute("width");
		svg.removeAttribute("height");

		return svg.toString().trim();
	});

	const symbols = await Promise.all(symbolPromises);

	const output = [
		`<?xml version="1.0" encoding="UTF-8"?>`,
		`<!-- This file is generated by npm run build:icons -->`,
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
		`<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
		...symbols,
		`</defs>`,
		`</svg>`,
		"", // trailing newline
	].join("\n");

	await writeIfChanged(outputPath, output);
}

async function writeIfChanged(filepath: string, newContent: string) {
	const readResult = await vet(() => fsExtra.readFile(filepath, "utf8"));
	// We use the unwrapOr to avoid throwing an error because they will be created if they don't exist
	const currentContent = readResult.unwrapOr("");

	if (currentContent === newContent) return;

	const writeResult = await vet(() =>
		fsExtra.writeFile(filepath, newContent, "utf8"),
	);
	if (writeResult.isErr()) {
		console.error(`Failed to write to ${filepath}`);
		throw writeResult.error;
	}
}
