/* eslint-disable @eslint-community/eslint-comments/disable-enable-pair */
/* eslint-disable import-x/no-named-as-default-member */
// Thanks to Epic Stack for the original script
// https://github.com/epicweb-dev/epic-stack/blob/d663177944e97f2705ec69482d3cc3c56865b2c8/other/build-icons.ts

import path from "node:path";

import { $ } from "execa";
import fsExtra from "fs-extra";
import { glob } from "glob";
import { parse } from "node-html-parser";

const cwd = process.cwd();
const inputDirectory = path.join(cwd, "src", "icons", "svg");
const inputDirectoryRelative = path.relative(cwd, inputDirectory);
const outputDirectory = path.join(cwd, "src", "icons");
const publicDirectory = path.join(cwd, "public");
const publicSvgDirectory = path.join(publicDirectory, "svg");

// Check if input directory exists
if (!fsExtra.existsSync(inputDirectory)) {
	throw new Error(`Input directory ${inputDirectoryRelative} not found`);
}

// Create output and public directories if they don't exist
await fsExtra.ensureDir(outputDirectory);
await fsExtra.ensureDir(publicDirectory);
await fsExtra.ensureDir(publicSvgDirectory);

const files = glob
	.sync("**/*.svg", {
		cwd: inputDirectory,
	})
	.sort((a, b) => {
		return a.localeCompare(b);
	});

const shouldVerboseLog = process.argv.includes("--log=verbose");
// eslint-disable-next-line @typescript-eslint/no-empty-function
const logVerbose = shouldVerboseLog ? console.log : () => {};

if (files.length === 0) {
	console.log(`No SVG files found in ${inputDirectoryRelative}`);
} else {
	await generateIconFiles();
}

async function generateIconFiles() {
	const spriteFilepath = path.join(publicDirectory, "svg/sprite.svg");
	const typeOutputFilepath = path.join(outputDirectory, "icon-name.d.ts");
	const currentSprite = await fsExtra
		.readFile(spriteFilepath, "utf8")
		.catch(() => {
			return "";
		});
	const currentTypes = await fsExtra
		.readFile(typeOutputFilepath, "utf8")
		.catch(() => {
			return "";
		});

	const iconNames = files.map((file) => {
		return iconName(file);
	});

	const spriteUpToDate = iconNames.every((name) => {
		return currentSprite.includes(`id=${name}`);
	});
	const typesUpToDate = iconNames.every((name) => {
		return currentTypes.includes(`"${name}"`);
	});

	if (spriteUpToDate && typesUpToDate) {
		logVerbose(`Icons are up to date`);
		return;
	}

	logVerbose(`Generating sprite for ${inputDirectoryRelative}`);

	const spriteChanged = await generateSvgSprite({
		filesProp: files,
		inputDirectoryProp: inputDirectory,
		outputPath: spriteFilepath,
	});
	await $`svgo --precision 2 ${spriteFilepath}`;

	for (const file of files) {
		logVerbose("âœ…", file);
	}

	logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

	const stringifiedIconNames = iconNames.map((name) => {
		return JSON.stringify(name);
	});

	const typeOutputContent = `// This file is generated by npm run build:icons

export type IconName =
\t| ${stringifiedIconNames.join("\n\t| ")};
`;
	const typesChanged = await writeIfChanged(
		typeOutputFilepath,
		typeOutputContent,
	);

	logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

	const readmeChanged = await writeIfChanged(
		path.join(outputDirectory, "README.md"),
		`# Icons

Everything in this directory is generated by \`pnpm run build:icons\`.
This directory contains SVG icon names that are used by the app.

Scripts are located in the \`scripts/build-icons.ts\` directory.
Original SVG files are located in the \`src/app/icons/svg\` directory.
The icon sprite is generated within the public directory at \`/svg/sprite.svg\`.
`,
	);

	if (spriteChanged || typesChanged || readmeChanged) {
		console.log(`Generated ${files.length} icons`);
	}
}

function iconName(file: string) {
	return file.replace(/\.svg$/u, "");
}

/**
 * Creates a single SVG file that contains all the icons
 * @param {object} options - Options for the sprite generation
 * @param {string[]} options.filesProp - List of SVG files to include
 * @param {string} options.inputDirectoryProp - Directory containing the SVG files
 * @param {string} options.outputPath - Output path for the sprite
 * @returns {Promise<boolean>} Whether the sprite was changed
 */
async function generateSvgSprite({
	filesProp,
	inputDirectoryProp,
	outputPath,
}: {
	filesProp: string[];
	inputDirectoryProp: string;
	outputPath: string;
}) {
	// Each SVG becomes a symbol and we wrap them all in a single SVG
	const symbols = await Promise.all(
		filesProp.map(async (file) => {
			const input = await fsExtra.readFile(
				path.join(inputDirectoryProp, file),
				"utf8",
			);
			const root = parse(input);

			const svg = root.querySelector("svg");
			if (!svg) throw new Error("No SVG element found");

			svg.tagName = "symbol";
			svg.setAttribute("id", iconName(file));
			svg.removeAttribute("xmlns");
			svg.removeAttribute("xmlns:xlink");
			svg.removeAttribute("version");
			svg.removeAttribute("width");
			svg.removeAttribute("height");

			return svg.toString().trim();
		}),
	);

	const output = [
		`<?xml version="1.0" encoding="UTF-8"?>`,
		`<!-- This file is generated by npm run build:icons -->`,
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
		`<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
		...symbols,
		`</defs>`,
		`</svg>`,
		"", // trailing newline
	].join("\n");

	return await writeIfChanged(outputPath, output);
}

async function writeIfChanged(filepath: string, newContent: string) {
	const currentContent = await fsExtra.readFile(filepath, "utf8").catch(() => {
		return "";
	});

	if (currentContent === newContent) return false;

	await fsExtra.writeFile(filepath, newContent, "utf8");

	return true;
}
